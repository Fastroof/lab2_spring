ЛР2

Роботу виконали студенти групи ІО-02:
- Воловик Олександр
- Литвиненко Данило
- Шумельчук Юрій

Варіант 16:
><b>Тема:</b> Оренда квартир
<br><b>Сутності:</b> Квартира, параметри квартири, опис
<br><b>Актори:</b> Хазяїн квартири, клієнт 
<br><b>Сценарії використання:</b> 
<br>Хазяїн квартири: Створення/редагування/видалення інформації про квартиру
<br>Клієнт: пошук квартири по параметрам

План
>Буде створено репозиторій користувача з різним рівнем доступу до інформації про квартиру (Власник може CRUD, а Клієнт тільки читати та шукати). Для викладення оголошення потрібно буде авторизуватися, а щоб переглядати - ні.

Контрольні питання:
1. Поясніть значення наступних термінів:
    - Inversion of Control (IoC);
    - IoC container;
    - Dependency Injection (DI);
    - Dependency inversion principle.
> <b>IoC (інверсія контролю)</b> - це концепція, яка переносить відповідальність за виконання дій із коду програми на фреймворк, тобто код не викликає бібліотеку і просе її допомогти, а навпаки фреймворк сам з'ясовує, що потрібно компонентам і надає їм це.<br> <b>IoC container</b> - це частина Spring або якась програма, яка дозволить вам спростити та автоматизувати написання коду з використанням IoC на стільки, наскільки це можливо. У Spring об’єкти, які утворюють основу вашої програми та якими керує контейнер Spring IoC, називаються компонентами. Компонент — це об’єкт, який створюється, збирається та іншим чином керується контейнером Spring IoC.<br> <b>Dependency Injection (ін'єкція залежності)</b> — це шаблон, який ми можемо використовувати для реалізації IoC, де інвертований елемент керування встановлює залежності об’єкта.<br> <b>Dependency inversion principle</b> - один із найвідоміших сьогодні принципів проектування, який лежить в основі популярних технік впровадження залежностей (Dependency Injection). Модулі верхнього рівня не повинні залежати від модулів нижнього рівня. І ті, й інші повинні залежати від абстракцій. Абстракції не повинні залежати від деталей. Деталі мають залежати від абстракцій.
2. В чому полягає різниця між анотаціями @Component та @Bean? Опишіть переваги та недоліки створення бінів за допомогою цих анотацій.
> @Component і @Bean роблять дві абсолютно різні речі, і їх не слід плутати. @Component використовується для автоматичного виявлення та автоматичного налаштування компонентів за допомогою сканування шляху до класів. Існує неявне відображення один-до-одного між анотованим класом і компонентом (тобто один компонент на клас). @Bean використовується для явного оголошення одного bean-компонента замість того, щоб дозволити Spring робити це автоматично, як описано вище. Він відокремлює оголошення bean-компонента від визначення класу та дозволяє створювати та налаштовувати bean-компоненти саме так, як ви виберете.<br> @Component бажано для сканування компонентів і автоматичного підключення, а @Bean якщо ви хочете зв’язати компоненти зі сторонніх бібліотек (у вас немає вихідного коду, тому ви не можете анотувати його класи за допомогою @Component), тому автоматичне налаштування неможливе.
3. Чому слід уникати ін’єкцій залежностей напряму у поле біна?
>  Ін’єкцій залежностей напряму у поле біна — це, ймовірно, найпростіша (але ризикована) форма впровадження залежностей. Проблеми:
>  - Ви не можете створити незмінні об’єкти, як це можна зробити за допомогою ін’єкції конструктора 
>  - Ваші класи тісно пов’язані з контейнером DI і не можуть використовуватися поза ним
>  - Ваші класи не можуть бути створені (наприклад, у модульних тестах) без рефлексії. Вам потрібен контейнер DI, щоб створити їх, що робить ваші тести більш схожими на інтеграційні тести
>  - Ваші реальні залежності приховані ззовні та не відображаються у вашому інтерфейсі (ані конструкторах, ані методах)
4. В яких випадках краще використовувати ін’єкції залежностей за допомогою конструкторів, а в яких за допомогою сетерів?
> Тільки сетери можна використати для поступового вровадження залежностей, тобто тоді коли треба і не буде проблеми при циркулярних залежностях. Можна легко змінити значення шляхом ін’єкції сеттера. Він не завжди створює новий екземпляр компонента, як конструктор. Отже, ін’єкція сетера є гнучкою, ніж ін’єкція конструктора. В усіх інших випадках конструктор є кращим варіантом.
5. В яких випадках краще використовувати біни типу singleton, а в яких prototype?
> Singleton (Default): лише один екземпляр буде створено для одного визначення bean-компонента на контейнер Spring IoC, і той самий об’єкт буде спільно використаний для кожного запиту, зробленого для цього bean-компонента. Prototype: новий екземпляр буде створено для визначення окремого bean-компонента кожного разу, коли буде зроблено запит для цього bean-компонента.
6. Чи можливе у Spring Framework створення циркулярних залежностей при ін’єкціях?
> Циклічна залежність у Spring виникає, коли два або більше bean-компонентів потребують екземплярів один одного через ін’єкції залежностей конструктора. Наприклад: існує ClassA, якому потрібен екземпляр ClassB через ін’єкцію конструктора, а для ClassB потрібен екземпляр класу A через ін’єкцію конструктора.<br> З циклічною залежністю Spring не може вирішити, який з bean-компонентів слід створити першим, оскільки вони залежать один від одного. У цих випадках Spring викличе BeanCurrentlyInCreationException під час завантаження контексту.<br> Якщо ми використовуємо інші типи ін’єкцій, у нас не повинно виникнути цієї проблеми, оскільки залежності будуть ін’єктовані, коли вони потрібні, а не під час завантаження контексту.
7. Чи може бути в одному проекті кілька класів з реалізацією якогось інтерфейсу, якщо цей інтерфейс використовується для ін’єкції залежностей?
> Може, але тоді треба допомогти Spring розрізнити різні реалізації одного інтерфейсу. Для цього можна використати анотацію @Qualifier (тут в дужка дреба дати назву), або заавтовайрить список (List) типу інтерфейса і він зробить ін'єкцію всіх реалізацій. Але ж який порядок буде у списку? - Для того, щоб знати явно, треба прописати @Order з числом, або @Primary, яка надає найвищий пріоритет. <br> ```@Autowired
private Map<String, StringCallable> map;```<br>
Spring автоматично підставить не тільки самі біни, а й імена бінів як ключі. Це може бути ефективно використано, наприклад, у патерні "стратегія".
8. Чи може бін мати кілька методів, помічених анотацією @Autowired?
> Звісно
9. Чи може бін мати кілька конструкторів, помічених анотацією @Autowired?
> Тільки один конструктор може мати анотацію @Autowired.
